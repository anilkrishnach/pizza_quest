export declare enum Endian {
    Little = "Little",
    Big = "Big"
}
export declare enum StructAlignment {
    Packed = "Packed",
    Align2Byte = "Align2Byte",
    Align4Byte = "Align4Byte",
    Align8Byte = "Align8Byte"
}
export declare enum AlignmentPadding {
    BeforeData = "BeforeData",
    AfterData = "AfterData"
}
export interface IField {
    computeBufferSize(): number;
    toUint8Array(): Uint8Array;
}
interface IValue<T> {
    set(value: T): void;
    get(): T;
}
export declare class StructType implements IField {
    private alignment;
    private paddingDirection;
    private fields;
    private fieldMap;
    name: string;
    constructor(name: string, alignment?: StructAlignment, paddingDirection?: AlignmentPadding);
    get<T extends ConstructDataType>(name: string): T;
    getDeep<T extends ConstructDataType>(path: string): T;
    getDeepOffset(path: string, startOffset?: number): number;
    getOffset(name: string): number;
    field(name: string, item: ConstructDataType): this;
    computeBufferSize(): number;
    toUint8Array(): Uint8Array;
}
declare type RelaxedArray<T> = T[] | Readonly<T[]>;
declare type ByteConversionStrategyFn = (ns: RelaxedArray<number>, isLittleEndian: boolean) => Uint8Array;
declare class BaseField implements IValue<number>, IField {
    private value;
    private endian;
    private width;
    private min;
    private max;
    private toBytesFn;
    constructor(width: number, min: number, max: number, toBytesFn: ByteConversionStrategyFn, value: number, endian: Endian);
    private assertInvariants;
    computeBufferSize(): number;
    toUint8Array(): Uint8Array;
    set(value: number): void;
    get(): number;
}
declare class U8Type extends BaseField {
    constructor(value: number, endian?: Endian);
}
declare class U16Type extends BaseField {
    constructor(value: number, endian?: Endian);
}
declare class U32Type extends BaseField {
    constructor(value: number, endian?: Endian);
}
declare class I8Type extends BaseField {
    constructor(value: number, endian?: Endian);
}
declare class I16Type extends BaseField {
    constructor(value: number, endian?: Endian);
}
declare class I32Type extends BaseField {
    constructor(value: number, endian?: Endian);
}
declare class BaseArrayField implements IValue<number[]>, IField {
    private values;
    private endian;
    private width;
    private min;
    private max;
    private toBytesFn;
    private assertInvariants;
    constructor(width: number, min: number, max: number, toBytesFn: ByteConversionStrategyFn, values: number[], endian?: Endian);
    computeBufferSize(): number;
    get(): number[];
    set(values: number[]): void;
    toUint8Array(): Uint8Array;
}
declare class U8sType extends BaseArrayField {
    constructor(values: number[], endian?: Endian);
}
declare class U16sType extends BaseArrayField {
    constructor(values: number[], endian?: Endian);
}
declare class U32sType extends BaseArrayField {
    constructor(values: number[], endian?: Endian);
}
declare class I8sType extends BaseArrayField {
    constructor(values: number[], endian?: Endian);
}
declare class I16sType extends BaseArrayField {
    constructor(values: number[], endian?: Endian);
}
declare class I32sType extends BaseArrayField {
    constructor(values: number[], endian?: Endian);
}
export declare class U64Type implements IValue<bigint>, IField {
    private value;
    private endian;
    private assertInvariants;
    constructor(value: bigint, endian?: Endian);
    computeBufferSize(): number;
    toUint8Array(): Uint8Array;
    set(value: bigint): void;
    get(): bigint;
}
export declare class I64Type implements IValue<bigint>, IField {
    private value;
    private endian;
    private assertInvariants;
    constructor(value: bigint, endian?: Endian);
    computeBufferSize(): number;
    toUint8Array(): Uint8Array;
    set(value: bigint): void;
    get(): bigint;
}
export declare class U64sType implements IValue<bigint[]>, IField {
    private values;
    private endian;
    private assertInvariants;
    constructor(values: bigint[], endian?: Endian);
    computeBufferSize(): number;
    get(): bigint[];
    set(values: bigint[]): void;
    toUint8Array(): Uint8Array;
}
export declare class I64sType implements IValue<bigint[]>, IField {
    private values;
    private endian;
    private assertInvariants;
    constructor(values: bigint[], endian?: Endian);
    computeBufferSize(): number;
    get(): bigint[];
    set(values: bigint[]): void;
    toUint8Array(): Uint8Array;
}
declare class BaseSizeOf implements IField {
    private target;
    private endian;
    private width;
    private toBytesFn;
    constructor(width: number, toBytesFn: ByteConversionStrategyFn, target: ConstructDataType, endian?: Endian);
    computeBufferSize(): number;
    toUint8Array(): Uint8Array;
    get(): number;
}
declare class SizeOf8Type extends BaseSizeOf {
    constructor(target: ConstructDataType, endian?: Endian);
}
declare class SizeOf16Type extends BaseSizeOf {
    constructor(target: ConstructDataType, endian?: Endian);
}
declare class SizeOf32Type extends BaseSizeOf {
    constructor(target: ConstructDataType, endian?: Endian);
}
export declare class SizeOf64Type implements IField {
    private target;
    private endian;
    constructor(target: ConstructDataType, endian?: Endian);
    computeBufferSize(): number;
    toUint8Array(): Uint8Array;
    get(): bigint;
}
declare class BasePointer implements IField {
    private target;
    private path;
    private endian;
    private width;
    private toBytesFn;
    constructor(width: number, toBytesFn: ByteConversionStrategyFn, target: StructType, path: string, endian?: Endian);
    computeBufferSize(): number;
    toUint8Array(): Uint8Array;
    get(): number;
}
declare class Pointer8Type extends BasePointer {
    constructor(target: StructType, path: string, endian?: Endian);
}
declare class Pointer16Type extends BasePointer {
    constructor(target: StructType, path: string, endian?: Endian);
}
declare class Pointer32Type extends BasePointer {
    constructor(target: StructType, path: string, endian?: Endian);
}
export declare class Pointer64Type implements IField {
    private target;
    private path;
    private endian;
    constructor(target: StructType, path: string, endian?: Endian);
    computeBufferSize(): number;
    toUint8Array(): Uint8Array;
    get(): bigint;
}
export declare class RawStringType implements IValue<string>, IField {
    private value;
    constructor(value: string);
    computeBufferSize(): number;
    toUint8Array(): Uint8Array;
    set(value: string): void;
    get(): string;
}
export declare class NullTerminatedStringType implements IValue<string>, IField {
    private value;
    constructor(value: string);
    computeBufferSize(): number;
    toUint8Array(): Uint8Array;
    set(value: string): void;
    get(): string;
}
export declare const Struct: (name: string, alignment?: StructAlignment, paddingDirection?: AlignmentPadding) => StructType;
export declare const U8: (value: number) => U8Type;
export declare const U16: (value: number, endian?: Endian) => U16Type;
export declare const U32: (value: number, endian?: Endian) => U32Type;
export declare const U64: (value: bigint, endian?: Endian) => U64Type;
export declare const I8: (value: number) => I8Type;
export declare const I16: (value: number, endian?: Endian) => I16Type;
export declare const I32: (value: number, endian?: Endian) => I32Type;
export declare const I64: (value: bigint, endian?: Endian) => I64Type;
export declare const U8s: (values: number[]) => U8sType;
export declare const U16s: (values: number[], endian?: Endian) => U16sType;
export declare const U32s: (values: number[], endian?: Endian) => U32sType;
export declare const U64s: (values: bigint[], endian?: Endian) => U64sType;
export declare const I8s: (values: number[]) => I8sType;
export declare const I16s: (values: number[], endian?: Endian) => I16sType;
export declare const I32s: (values: number[], endian?: Endian) => I32sType;
export declare const I64s: (values: bigint[], endian?: Endian) => I64sType;
export declare const SizeOf8: (target: ConstructDataType) => SizeOf8Type;
export declare const SizeOf16: (target: ConstructDataType, endian?: Endian) => SizeOf16Type;
export declare const SizeOf32: (target: ConstructDataType, endian?: Endian) => SizeOf32Type;
export declare const SizeOf64: (target: ConstructDataType, endian?: Endian) => SizeOf64Type;
export declare const Pointer8: (target: StructType, path: string) => Pointer8Type;
export declare const Pointer16: (target: StructType, path: string, endian?: Endian) => Pointer16Type;
export declare const Pointer32: (target: StructType, path: string, endian?: Endian) => Pointer32Type;
export declare const Pointer64: (target: StructType, path: string, endian?: Endian) => Pointer64Type;
export declare const RawString: (value: string) => RawStringType;
export declare const NullTerminatedString: (value: string) => NullTerminatedStringType;
export declare type ConstructDataType = StructType | IField;
export declare type DataType<T extends (...args: any[]) => ConstructDataType> = ReturnType<T>;
export {};
